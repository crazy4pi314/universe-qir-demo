# Let's start with a basic Bell state program in Q#
code ./demo/qsharp/BellMeas/Program.qs
# We can compile this into QIR
compile-qsharp ./demo/qsharp/BellMeas/
# Let's walk through the QIR
code ./BellMeas.ll
# Then execute with the Microsoft QDK
qdk-run ./BellMeas.bc 500
# Ok, now try a simplified Bernstein-Vazirani algorithm
code ./demo/qsharp/BV/Bernsteinâ€“Vazirani.qs
# Compile into QIR, this time using a target package
compile-qsharp ./demo/qsharp/BV
# This QIR uses loops and an alternate gate set determined by the target
code ./Bernstein-Vazirani.ll
# We can still execute this with QDK
qdk-run ./Bernstein-Vazirani.bc 500
# Now, run the same program on PNNL's Density Matrix simulation (CPU), with a noisy H-gate
pnnl-run ./Bernstein-Vazirani.bc 500
# The noise profile means we get different results each time
pnnl-run ./Bernstein-Vazirani.bc 500
# Using LLVM tools like clang or opt, we can optimize QIR out of the box
opt-11 -S ./Bernstein-Vazirani.bc -inline -globaldce -o ./Bernstein-Vazirani.opt.ll
code ./Bernstein-Vazirani.opt.ll
# We can even run the full "O3" optimization pass
clang++-11 -w -S ./Bernstein-Vazirani.bc -O3 -emit-llvm -o ./Bernstein-Vazirani.O3.ll
# This new QIR after full optimization pass shows inlining, loop unrolling, and constant propagation
code ./Bernstein-Vazirani.O3.ll
# RUN ON RIGETTI QPU!!!
